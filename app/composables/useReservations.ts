import type { Reservation, ReservationFilters, ReservationResponse, ReservationStats } from '~/types/reservation'

export const useReservations = () => {
  const { $myFetch } = useNuxtApp()
  const loading = ref(false)
  const error = ref<string | null>(null)

  /**
   * R√©cup√®re toutes les r√©servations avec statistiques
   */
  const fetchReservations = async (filters: ReservationFilters = {}): Promise<{
    data: Reservation[]
    meta: {
      current_page: number
      from: number
      last_page: number
      per_page: number
      to: number
      total: number
    }
    stats: ReservationStats
  }> => {
    try {
      loading.value = true
      error.value = null

      // Construire l'URL avec les filtres
      let url = '/reservations'
      const queryParams = new URLSearchParams()
      
      // Nouveaux filtres
      if (filters.search) {
        queryParams.append('search', filters.search)
      }
      if (filters.date_from) {
        queryParams.append('date_from', filters.date_from)
      }
      if (filters.date_to) {
        queryParams.append('date_to', filters.date_to)
      }
      if (filters.event_id) {
        queryParams.append('event_id', filters.event_id.toString())
      }
      if (filters.user_id) {
        queryParams.append('user_id', filters.user_id.toString())
      }
      if (filters.status) {
        queryParams.append('status', filters.status)
      }
      if (filters.payment_status) {
        queryParams.append('payment_status', filters.payment_status)
      }
      if (filters.per_page) {
        queryParams.append('per_page', filters.per_page.toString())
      }
      if (filters.page) {
        queryParams.append('page', filters.page.toString())
      }
      
      // Filtres de compatibilit√© (legacy)
      if (filters.reservation_form_id) {
        queryParams.append('reservation_form_id', filters.reservation_form_id.toString())
      }
      
      if (queryParams.toString()) {
        url += '?' + queryParams.toString()
      }
      
      console.log('URL de requ√™te:', url)
      
      const response = await $myFetch<ReservationResponse>(url, {
        method: 'GET'
      })
      
      // L'API retourne {data: [r√©servations...], pagination: {...}, stats: {...}}
      const reservations = response?.data ?? []
      const pagination = response?.pagination || {}
      const stats = response?.stats || { total: 0, by_status: { confirmed: 0, pending: 0, cancelled: 0 } }
      
      if (process.client && process.dev) {
        console.log('[API] /reservations', { filters, raw: response, reservations: reservations.length, pagination, stats })
      }

      // Retourner dans le format attendu par le composant
      return {
        data: reservations,
        meta: {
          current_page: pagination.current_page || 1,
          from: ((pagination.current_page || 1) - 1) * (pagination.per_page || 15) + 1,
          last_page: pagination.last_page || 1,
          per_page: pagination.per_page || filters.per_page || 15,
          to: Math.min((pagination.current_page || 1) * (pagination.per_page || 15), pagination.total || 0),
          total: pagination.total || reservations.length
        },
        stats
      }
    } catch (err: any) {
      const errorMessage = err?.response?.data?.message || err?.message || 'Erreur lors de la r√©cup√©ration des r√©servations'
      error.value = errorMessage
      throw new Error(errorMessage)
    } finally {
      loading.value = false
    }
  }

  /**
   * R√©cup√®re une r√©servation par ID
   */
  const fetchReservation = async (id: number): Promise<Reservation> => {
    try {
      loading.value = true
      error.value = null

      const response = await $myFetch<any>(`/reservations/${id}`, {
        method: 'GET'
      })
      
      // D√©baller l'enveloppe standard { status, message, data }
      const reservation = response?.data ?? response
      
      if (process.client && process.dev) {
        console.log('[API] /reservations/:id', { id, raw: response, reservation })
      }

      return reservation
    } catch (err: any) {
      const errorMessage = err?.response?.data?.message || err?.message || 'Erreur lors de la r√©cup√©ration de la r√©servation'
      error.value = errorMessage
      throw new Error(errorMessage)
    } finally {
      loading.value = false
    }
  }

  /**
   * Met √† jour le statut d'une r√©servation
   */
  const updateReservationStatus = async (id: number, status: 'pending' | 'confirmed' | 'cancelled'): Promise<Reservation> => {
    try {
      loading.value = true
      error.value = null

      const response = await $myFetch<any>(`/reservations/${id}`, {
        method: 'PUT',
        body: { status }
      })
      
      // D√©baller l'enveloppe standard { status, message, data }
      const reservation = response?.data ?? response
      
      if (process.client && process.dev) {
        console.log('[API] PUT /reservations/:id', { id, status, raw: response, reservation })
      }

      return reservation
    } catch (err: any) {
      const errorMessage = err?.response?.data?.message || err?.message || 'Erreur lors de la mise √† jour de la r√©servation'
      error.value = errorMessage
      throw new Error(errorMessage)
    } finally {
      loading.value = false
    }
  }

  /**
   * Supprime une r√©servation
   */
  const deleteReservation = async (id: number): Promise<void> => {
    try {
      loading.value = true
      error.value = null

      const response = await $myFetch<any>(`/reservations/${id}`, {
        method: 'DELETE'
      })
      
      if (process.client && process.dev) {
        console.log('[API] DELETE /reservations/:id', { id, raw: response })
      }
    } catch (err: any) {
      const errorMessage = err?.response?.data?.message || err?.message || 'Erreur lors de la suppression de la r√©servation'
      error.value = errorMessage
      throw new Error(errorMessage)
    } finally {
      loading.value = false
    }
  }

  /**
   * Formate la date de r√©servation
   */
  const formatReservationDate = (date: string | null): string => {
    if (!date) return '‚Äî'
    return new Date(date).toLocaleDateString('fr-FR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })
  }

  /**
   * Obtient la couleur du badge selon le statut
   */
  const getStatusColor = (status: string): string => {
    switch (status) {
      case 'confirmed': return 'success'
      case 'pending': return 'warning'
      case 'cancelled': return 'error'
      default: return 'neutral'
    }
  }

  /**
   * Obtient la couleur du badge selon le statut de paiement
   */
  const getPaymentStatusColor = (paymentStatus: string): string => {
    switch (paymentStatus) {
      case 'paid': return 'success'
      case 'pending': return 'warning'
      case 'failed': return 'error'
      case 'refunded': return 'neutral'
      default: return 'neutral'
    }
  }

  /**
   * Obtient le libell√© du statut en fran√ßais
   */
  const getStatusLabel = (status: string): string => {
    switch (status) {
      case 'confirmed': return 'Confirm√©e'
      case 'pending': return 'En attente'
      case 'cancelled': return 'Annul√©e'
      default: return status
    }
  }

  /**
   * Obtient le libell√© du statut de paiement en fran√ßais
   */
  const getPaymentStatusLabel = (paymentStatus: string): string => {
    switch (paymentStatus) {
      case 'paid': return 'Pay√©'
      case 'pending': return 'En attente'
      case 'failed': return '√âchou√©'
      case 'refunded': return 'Rembours√©'
      default: return paymentStatus
    }
  }

  /**
   * Exporte les r√©servations dans le format sp√©cifi√©
   */
  const exportReservations = async (
    format: 'csv' | 'excel' | 'pdf', 
    filters: ReservationFilters = {}
  ): Promise<void> => {
    try {
      loading.value = true
      error.value = null

      // Construire l'URL compl√®te avec les filtres
      let url = 'https://api.bisoticket.com/api/reservations/export'
      const queryParams = new URLSearchParams()
      
      // Format d'export
      queryParams.append('format', format)
      
      // Appliquer les m√™mes filtres que pour la r√©cup√©ration
      if (filters.search) {
        queryParams.append('search', filters.search)
      }
      if (filters.date_from) {
        queryParams.append('date_from', filters.date_from)
      }
      if (filters.date_to) {
        queryParams.append('date_to', filters.date_to)
      }
      if (filters.event_id) {
        queryParams.append('event_id', filters.event_id.toString())
      }
      if (filters.user_id) {
        queryParams.append('user_id', filters.user_id.toString())
      }
      if (filters.status) {
        queryParams.append('status', filters.status)
      }
      if (filters.payment_status) {
        queryParams.append('payment_status', filters.payment_status)
      }
      
      // Filtres de compatibilit√© (legacy)
      if (filters.reservation_form_id) {
        queryParams.append('reservation_form_id', filters.reservation_form_id.toString())
      }
      
      if (queryParams.toString()) {
        url += '?' + queryParams.toString()
      }
      
      console.log('üöÄ Export des r√©servations:', { format, filters, url })
      console.log('üîó URL compl√®te:', `${url}?${queryParams.toString()}`)
      
      // R√©cup√©rer le token d'authentification
      const token = useCookie('auth_token').value
      if (!token) {
        throw new Error('Token d\'authentification manquant')
      }
      
      // Faire la requ√™te pour t√©l√©charger le fichier avec fetch
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Accept': format === 'pdf' ? 'application/pdf' : 
                   format === 'excel' ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' : 
                   'text/csv'
        }
      })
      
      if (!response.ok) {
        // Gestion d'erreurs selon le guide
        if (response.status === 401) {
          throw new Error('Non authentifi√© - Veuillez vous reconnecter')
        } else if (response.status === 422) {
          throw new Error('Param√®tres invalides - V√©rifiez les filtres')
        } else if (response.status === 500) {
          throw new Error('Erreur serveur - R√©essayez plus tard')
        } else {
          throw new Error(`Erreur HTTP ${response.status}: ${response.statusText}`)
        }
      }
      
      console.log('üì° R√©ponse du serveur:', {
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries()),
        url: response.url
      })
      
      // R√©cup√©rer le blob
      const blob = await response.blob()
      
      console.log('üìÑ Informations du blob:', {
        size: blob.size,
        type: blob.type,
        format: format
      })
      
      // V√©rifier que le blob n'est pas vide
      if (blob.size === 0) {
        throw new Error('Le fichier export√© est vide')
      }
      
      // Pour le PDF, v√©rifier le contenu
      if (format === 'pdf') {
        const arrayBuffer = await blob.arrayBuffer()
        const uint8Array = new Uint8Array(arrayBuffer)
        const pdfHeader = String.fromCharCode(...uint8Array.slice(0, 4))
        console.log('üìÑ En-t√™te PDF:', pdfHeader)
        console.log('üìÑ Premiers 50 caract√®res:', String.fromCharCode(...uint8Array.slice(0, 50)))
        
        if (pdfHeader !== '%PDF') {
          console.warn('‚ö†Ô∏è Le fichier ne semble pas √™tre un PDF valide')
          // Essayer de lire comme texte pour voir l'erreur
          const text = await blob.text()
          console.log('üìã Contenu re√ßu (texte):', text)
          console.log('üìã Taille du contenu:', text.length)
          
          // Essayer de parser comme JSON pour voir l'erreur du serveur
          try {
            const jsonData = JSON.parse(text)
            console.log('üìã Donn√©es JSON du serveur:', jsonData)
            throw new Error(`Erreur du serveur: ${jsonData.message || 'Format non support√©'}`)
          } catch (jsonErr) {
            console.log('üìã Ce n\'est pas du JSON, contenu brut:', text.substring(0, 200))
            throw new Error('Le serveur n\'a pas retourn√© un PDF valide')
          }
        }
      }
      
      // Cr√©er l'URL de t√©l√©chargement
      const downloadUrl = window.URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = downloadUrl
      
      // Nom du fichier avec timestamp selon le guide
      const timestamp = new Date().toISOString().split('T')[0]
      const extension = format === 'excel' ? 'xlsx' : format
      const filename = `reservations_${timestamp}.${extension}`
      link.download = filename
      
      // D√©clencher le t√©l√©chargement
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      
      // Nettoyer l'URL
      window.URL.revokeObjectURL(downloadUrl)
      
      console.log(`‚úÖ ${format.toUpperCase()} t√©l√©charg√© avec succ√®s: ${filename}`)
      
      if (process.client && process.dev) {
        console.log('[API] /reservations/export', { format, filters, success: true })
      }
      
    } catch (err: any) {
      const errorMessage = err?.response?.data?.message || err?.message || 'Erreur lors de l\'export des r√©servations'
      error.value = errorMessage
      throw new Error(errorMessage)
    } finally {
      loading.value = false
    }
  }

  return {
    loading: readonly(loading),
    error: readonly(error),
    fetchReservations,
    fetchReservation,
    updateReservationStatus,
    deleteReservation,
    exportReservations,
    formatReservationDate,
    getStatusColor,
    getPaymentStatusColor,
    getStatusLabel,
    getPaymentStatusLabel
  }
}
